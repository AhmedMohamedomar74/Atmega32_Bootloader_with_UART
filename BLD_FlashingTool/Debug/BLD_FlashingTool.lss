
BLD_FlashingTool.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000077e  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000010d  00800060  00800060  00000812  2**0
                  ALLOC
  2 .eeprom       00000002  00810000  00810000  00000812  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .stab         000014b8  00000000  00000000  00000814  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001089  00000000  00000000  00001ccc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 2a 38 	jmp	0x7054	; 0x7054 <__ctors_end>
    7004:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7008:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    700c:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7010:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7014:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7018:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    701c:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7020:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7024:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7028:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    702c:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7030:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7034:	0c 94 5f 3b 	jmp	0x76be	; 0x76be <__vector_13>
    7038:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    703c:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7040:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7044:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7048:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    704c:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>
    7050:	0c 94 3c 38 	jmp	0x7078	; 0x7078 <__bad_interrupt>

00007054 <__ctors_end>:
    7054:	11 24       	eor	r1, r1
    7056:	1f be       	out	0x3f, r1	; 63
    7058:	cf e5       	ldi	r28, 0x5F	; 95
    705a:	d8 e0       	ldi	r29, 0x08	; 8
    705c:	de bf       	out	0x3e, r29	; 62
    705e:	cd bf       	out	0x3d, r28	; 61

00007060 <__do_clear_bss>:
    7060:	11 e0       	ldi	r17, 0x01	; 1
    7062:	a0 e6       	ldi	r26, 0x60	; 96
    7064:	b0 e0       	ldi	r27, 0x00	; 0
    7066:	01 c0       	rjmp	.+2      	; 0x706a <.do_clear_bss_start>

00007068 <.do_clear_bss_loop>:
    7068:	1d 92       	st	X+, r1

0000706a <.do_clear_bss_start>:
    706a:	ad 36       	cpi	r26, 0x6D	; 109
    706c:	b1 07       	cpc	r27, r17
    706e:	e1 f7       	brne	.-8      	; 0x7068 <.do_clear_bss_loop>
    7070:	0e 94 4a 38 	call	0x7094	; 0x7094 <main>
    7074:	0c 94 bd 3b 	jmp	0x777a	; 0x777a <_exit>

00007078 <__bad_interrupt>:
    7078:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

0000707c <APP_vidMoveIVT>:
}

extern void APP_vidMoveIVT(u8 u8Section)
{
	/*Move IVt to Application [starting from 0]*/
	if(u8Section == APP_SECTION)
    707c:	88 23       	and	r24, r24
    707e:	29 f4       	brne	.+10     	; 0x708a <APP_vidMoveIVT+0xe>
	{
		/* Enable change of interrupt vectors */
		GICR = (1<<IVCE);
    7080:	81 e0       	ldi	r24, 0x01	; 1
    7082:	8b bf       	out	0x3b, r24	; 59
		/* Move interrupts to Application section */
		clr_bit(GICR,IVSEL);
    7084:	8b b7       	in	r24, 0x3b	; 59
    7086:	8d 7f       	andi	r24, 0xFD	; 253
    7088:	03 c0       	rjmp	.+6      	; 0x7090 <APP_vidMoveIVT+0x14>

	/*Move IVt to Bootloader [starting after end of app section]*/
	else
	{
		/* Enable change of interrupt vectors */
		GICR = (1<<IVCE);
    708a:	81 e0       	ldi	r24, 0x01	; 1
    708c:	8b bf       	out	0x3b, r24	; 59
		/* Move interrupts to boot Flash section */
		GICR = (1<<IVSEL);
    708e:	82 e0       	ldi	r24, 0x02	; 2
    7090:	8b bf       	out	0x3b, r24	; 59
    7092:	08 95       	ret

00007094 <main>:


char eedata[] EEMEM = {0x00,0x00};

int main(void)
{
    7094:	0f 93       	push	r16
    7096:	1f 93       	push	r17
	u8 validAPP_Val, reqFromApp_Val;
	validAPP_Val = eeprom_read_byte (VALID_APP_ADDRESS);
    7098:	80 e0       	ldi	r24, 0x00	; 0
    709a:	90 e0       	ldi	r25, 0x00	; 0
    709c:	0e 94 a4 3b 	call	0x7748	; 0x7748 <__eerd_byte_m32>
    70a0:	08 2f       	mov	r16, r24
	reqFromApp_Val = eeprom_read_byte (REQ_FROM_APP_ADDRESS);
    70a2:	81 e0       	ldi	r24, 0x01	; 1
    70a4:	90 e0       	ldi	r25, 0x00	; 0
    70a6:	0e 94 a4 3b 	call	0x7748	; 0x7748 <__eerd_byte_m32>

	if ( (validAPP_Val != 1) | (reqFromApp_Val == 1))
    70aa:	10 e0       	ldi	r17, 0x00	; 0
    70ac:	81 30       	cpi	r24, 0x01	; 1
    70ae:	09 f4       	brne	.+2      	; 0x70b2 <main+0x1e>
    70b0:	11 e0       	ldi	r17, 0x01	; 1
    70b2:	01 30       	cpi	r16, 0x01	; 1
    70b4:	11 f4       	brne	.+4      	; 0x70ba <main+0x26>
    70b6:	11 23       	and	r17, r17
    70b8:	29 f1       	breq	.+74     	; 0x7104 <main+0x70>
	{
		/*for debugging*/
		DIO_vidSetPinDir(PORTA , PIN7 , OUTPUT);
    70ba:	81 e0       	ldi	r24, 0x01	; 1
    70bc:	67 e0       	ldi	r22, 0x07	; 7
    70be:	41 e0       	ldi	r20, 0x01	; 1
    70c0:	0e 94 b1 38 	call	0x7162	; 0x7162 <DIO_vidSetPinDir>
		DIO_vidSetPinValue(PORTA , PIN7 , HIGH);
    70c4:	81 e0       	ldi	r24, 0x01	; 1
    70c6:	67 e0       	ldi	r22, 0x07	; 7
    70c8:	41 e0       	ldi	r20, 0x01	; 1
    70ca:	0e 94 42 39 	call	0x7284	; 0x7284 <DIO_vidSetPinValue>


		UART_Init();
    70ce:	0e 94 4c 3b 	call	0x7698	; 0x7698 <UART_Init>
		DIO_vidSetPinDir(PORTD , PIN0 , INPUT);
    70d2:	84 e0       	ldi	r24, 0x04	; 4
    70d4:	60 e0       	ldi	r22, 0x00	; 0
    70d6:	40 e0       	ldi	r20, 0x00	; 0
    70d8:	0e 94 b1 38 	call	0x7162	; 0x7162 <DIO_vidSetPinDir>
		DIO_vidSetPinDir(PORTD , PIN1 , OUTPUT);
    70dc:	84 e0       	ldi	r24, 0x04	; 4
    70de:	61 e0       	ldi	r22, 0x01	; 1
    70e0:	41 e0       	ldi	r20, 0x01	; 1
    70e2:	0e 94 b1 38 	call	0x7162	; 0x7162 <DIO_vidSetPinDir>
#if USE_INTERRUPT == 1
		/*Move Vector Table to boot loader section*/
		APP_vidMoveIVT(BLD_SECTION);
    70e6:	81 e0       	ldi	r24, 0x01	; 1
    70e8:	0e 94 3e 38 	call	0x707c	; 0x707c <APP_vidMoveIVT>
#endif

		if(reqFromApp_Val == 1)
    70ec:	11 23       	and	r17, r17
    70ee:	39 f0       	breq	.+14     	; 0x70fe <main+0x6a>
		{
			flashingMngr_vidHandleReqFromApp() ;
    70f0:	0e 94 4c 3a 	call	0x7498	; 0x7498 <flashingMngr_vidHandleReqFromApp>
			/*clr application request*/
			eeprom_update_byte (REQ_FROM_APP_ADDRESS, 0);
    70f4:	81 e0       	ldi	r24, 0x01	; 1
    70f6:	90 e0       	ldi	r25, 0x00	; 0
    70f8:	60 e0       	ldi	r22, 0x00	; 0
    70fa:	0e 94 ac 3b 	call	0x7758	; 0x7758 <__eeupd_byte_m32>
		while(1)
		{
		#if USE_INTERRUPT == 0
			UART_vidRxHandler();
		#endif
			flashingMngr_vidMainTask() ;
    70fe:	0e 94 56 3a 	call	0x74ac	; 0x74ac <flashingMngr_vidMainTask>
    7102:	fd cf       	rjmp	.-6      	; 0x70fe <main+0x6a>
		}
	}
	else
	{
		/*Valid app, jump directly*/
		asm("jmp 0");
    7104:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
	}

	return 1 ;
}
    7108:	81 e0       	ldi	r24, 0x01	; 1
    710a:	90 e0       	ldi	r25, 0x00	; 0
    710c:	1f 91       	pop	r17
    710e:	0f 91       	pop	r16
    7110:	08 95       	ret

00007112 <DIO_vidSetPortDir>:



void DIO_vidSetPortDir(u8 u8portName, u8 u8PortDir)
{
	switch (u8portName)
    7112:	82 30       	cpi	r24, 0x02	; 2
    7114:	89 f0       	breq	.+34     	; 0x7138 <DIO_vidSetPortDir+0x26>
    7116:	83 30       	cpi	r24, 0x03	; 3
    7118:	18 f4       	brcc	.+6      	; 0x7120 <DIO_vidSetPortDir+0xe>
    711a:	81 30       	cpi	r24, 0x01	; 1
    711c:	09 f5       	brne	.+66     	; 0x7160 <DIO_vidSetPortDir+0x4e>
    711e:	05 c0       	rjmp	.+10     	; 0x712a <DIO_vidSetPortDir+0x18>
    7120:	83 30       	cpi	r24, 0x03	; 3
    7122:	89 f0       	breq	.+34     	; 0x7146 <DIO_vidSetPortDir+0x34>
    7124:	84 30       	cpi	r24, 0x04	; 4
    7126:	e1 f4       	brne	.+56     	; 0x7160 <DIO_vidSetPortDir+0x4e>
    7128:	15 c0       	rjmp	.+42     	; 0x7154 <DIO_vidSetPortDir+0x42>
	{
		case PORTA :
		{
			if(u8PortDir == INPUT)
    712a:	66 23       	and	r22, r22
    712c:	11 f4       	brne	.+4      	; 0x7132 <DIO_vidSetPortDir+0x20>
			{
				DDRA_REGISTER = 0x00 ;
    712e:	1a ba       	out	0x1a, r1	; 26
    7130:	08 95       	ret
			}
			else /*Direction is output*/
			{
				DDRA_REGISTER = 0xFF ;
    7132:	8f ef       	ldi	r24, 0xFF	; 255
    7134:	8a bb       	out	0x1a, r24	; 26
    7136:	08 95       	ret
			}
		}break;

		case PORTB :
		{
			if(u8PortDir == INPUT)
    7138:	66 23       	and	r22, r22
    713a:	11 f4       	brne	.+4      	; 0x7140 <DIO_vidSetPortDir+0x2e>
			{
				DDRB_REGISTER = 0x00 ;
    713c:	17 ba       	out	0x17, r1	; 23
    713e:	08 95       	ret
			}
			else /*Direction is output*/
			{
				DDRB_REGISTER = 0xFF ;
    7140:	8f ef       	ldi	r24, 0xFF	; 255
    7142:	87 bb       	out	0x17, r24	; 23
    7144:	08 95       	ret
			}
		}break;

		case PORTC :
		{
			if(u8PortDir == INPUT)
    7146:	66 23       	and	r22, r22
    7148:	11 f4       	brne	.+4      	; 0x714e <DIO_vidSetPortDir+0x3c>
			{
				DDRC_REGISTER = 0x00 ;
    714a:	14 ba       	out	0x14, r1	; 20
    714c:	08 95       	ret
			}
			else /*Direction is output*/
			{
				DDRC_REGISTER = 0xFF ;
    714e:	8f ef       	ldi	r24, 0xFF	; 255
    7150:	84 bb       	out	0x14, r24	; 20
    7152:	08 95       	ret
			}
		}break;

		case PORTD :
		{
			if(u8PortDir == INPUT)
    7154:	66 23       	and	r22, r22
    7156:	11 f4       	brne	.+4      	; 0x715c <DIO_vidSetPortDir+0x4a>
			{
				DDRD_REGISTER = 0x00 ;
    7158:	11 ba       	out	0x11, r1	; 17
    715a:	08 95       	ret
			}
			else /*Direction is output*/
			{
				DDRD_REGISTER = 0xFF ;
    715c:	8f ef       	ldi	r24, 0xFF	; 255
    715e:	81 bb       	out	0x11, r24	; 17
    7160:	08 95       	ret

00007162 <DIO_vidSetPinDir>:
}



void DIO_vidSetPinDir(u8 u8portName, u8 u8pinNo , u8 u8PinDir){
	switch (u8portName)
    7162:	82 30       	cpi	r24, 0x02	; 2
    7164:	49 f1       	breq	.+82     	; 0x71b8 <DIO_vidSetPinDir+0x56>
    7166:	83 30       	cpi	r24, 0x03	; 3
    7168:	20 f4       	brcc	.+8      	; 0x7172 <DIO_vidSetPinDir+0x10>
    716a:	81 30       	cpi	r24, 0x01	; 1
    716c:	09 f0       	breq	.+2      	; 0x7170 <DIO_vidSetPinDir+0xe>
    716e:	75 c0       	rjmp	.+234    	; 0x725a <DIO_vidSetPinDir+0xf8>
    7170:	07 c0       	rjmp	.+14     	; 0x7180 <DIO_vidSetPinDir+0x1e>
    7172:	83 30       	cpi	r24, 0x03	; 3
    7174:	09 f4       	brne	.+2      	; 0x7178 <DIO_vidSetPinDir+0x16>
    7176:	3c c0       	rjmp	.+120    	; 0x71f0 <DIO_vidSetPinDir+0x8e>
    7178:	84 30       	cpi	r24, 0x04	; 4
    717a:	09 f0       	breq	.+2      	; 0x717e <DIO_vidSetPinDir+0x1c>
    717c:	6e c0       	rjmp	.+220    	; 0x725a <DIO_vidSetPinDir+0xf8>
    717e:	53 c0       	rjmp	.+166    	; 0x7226 <DIO_vidSetPinDir+0xc4>
	{
		case PORTA :
		{
			if (u8PinDir == INPUT)
    7180:	44 23       	and	r20, r20
    7182:	61 f4       	brne	.+24     	; 0x719c <DIO_vidSetPinDir+0x3a>
			{
				clr_bit(DDRA_REGISTER ,u8pinNo);
    7184:	2a b3       	in	r18, 0x1a	; 26
    7186:	81 e0       	ldi	r24, 0x01	; 1
    7188:	90 e0       	ldi	r25, 0x00	; 0
    718a:	02 c0       	rjmp	.+4      	; 0x7190 <DIO_vidSetPinDir+0x2e>
    718c:	88 0f       	add	r24, r24
    718e:	99 1f       	adc	r25, r25
    7190:	6a 95       	dec	r22
    7192:	e2 f7       	brpl	.-8      	; 0x718c <DIO_vidSetPinDir+0x2a>
    7194:	80 95       	com	r24
    7196:	82 23       	and	r24, r18
    7198:	8a bb       	out	0x1a, r24	; 26
    719a:	08 95       	ret
			}
			else if (u8PinDir == OUTPUT)
    719c:	41 30       	cpi	r20, 0x01	; 1
    719e:	09 f0       	breq	.+2      	; 0x71a2 <DIO_vidSetPinDir+0x40>
    71a0:	5c c0       	rjmp	.+184    	; 0x725a <DIO_vidSetPinDir+0xf8>
			{
				set_bit(DDRA_REGISTER , u8pinNo );
    71a2:	2a b3       	in	r18, 0x1a	; 26
    71a4:	81 e0       	ldi	r24, 0x01	; 1
    71a6:	90 e0       	ldi	r25, 0x00	; 0
    71a8:	02 c0       	rjmp	.+4      	; 0x71ae <DIO_vidSetPinDir+0x4c>
    71aa:	88 0f       	add	r24, r24
    71ac:	99 1f       	adc	r25, r25
    71ae:	6a 95       	dec	r22
    71b0:	e2 f7       	brpl	.-8      	; 0x71aa <DIO_vidSetPinDir+0x48>
    71b2:	28 2b       	or	r18, r24
    71b4:	2a bb       	out	0x1a, r18	; 26
    71b6:	08 95       	ret

		}break;

		case PORTB :
		{
			if (u8PinDir == INPUT)
    71b8:	44 23       	and	r20, r20
    71ba:	61 f4       	brne	.+24     	; 0x71d4 <DIO_vidSetPinDir+0x72>
			{
				clr_bit(DDRB_REGISTER ,u8pinNo);
    71bc:	27 b3       	in	r18, 0x17	; 23
    71be:	81 e0       	ldi	r24, 0x01	; 1
    71c0:	90 e0       	ldi	r25, 0x00	; 0
    71c2:	02 c0       	rjmp	.+4      	; 0x71c8 <DIO_vidSetPinDir+0x66>
    71c4:	88 0f       	add	r24, r24
    71c6:	99 1f       	adc	r25, r25
    71c8:	6a 95       	dec	r22
    71ca:	e2 f7       	brpl	.-8      	; 0x71c4 <DIO_vidSetPinDir+0x62>
    71cc:	80 95       	com	r24
    71ce:	82 23       	and	r24, r18
    71d0:	87 bb       	out	0x17, r24	; 23
    71d2:	08 95       	ret
			}
			else if (u8PinDir == OUTPUT)
    71d4:	41 30       	cpi	r20, 0x01	; 1
    71d6:	09 f0       	breq	.+2      	; 0x71da <DIO_vidSetPinDir+0x78>
    71d8:	40 c0       	rjmp	.+128    	; 0x725a <DIO_vidSetPinDir+0xf8>
			{
				set_bit(DDRB_REGISTER , u8pinNo );
    71da:	27 b3       	in	r18, 0x17	; 23
    71dc:	81 e0       	ldi	r24, 0x01	; 1
    71de:	90 e0       	ldi	r25, 0x00	; 0
    71e0:	02 c0       	rjmp	.+4      	; 0x71e6 <DIO_vidSetPinDir+0x84>
    71e2:	88 0f       	add	r24, r24
    71e4:	99 1f       	adc	r25, r25
    71e6:	6a 95       	dec	r22
    71e8:	e2 f7       	brpl	.-8      	; 0x71e2 <DIO_vidSetPinDir+0x80>
    71ea:	28 2b       	or	r18, r24
    71ec:	27 bb       	out	0x17, r18	; 23
    71ee:	08 95       	ret
			}
		}break;

		case PORTC :
		{
			if (u8PinDir == INPUT)
    71f0:	44 23       	and	r20, r20
    71f2:	61 f4       	brne	.+24     	; 0x720c <DIO_vidSetPinDir+0xaa>
			{
				clr_bit(DDRC_REGISTER ,u8pinNo);
    71f4:	24 b3       	in	r18, 0x14	; 20
    71f6:	81 e0       	ldi	r24, 0x01	; 1
    71f8:	90 e0       	ldi	r25, 0x00	; 0
    71fa:	02 c0       	rjmp	.+4      	; 0x7200 <DIO_vidSetPinDir+0x9e>
    71fc:	88 0f       	add	r24, r24
    71fe:	99 1f       	adc	r25, r25
    7200:	6a 95       	dec	r22
    7202:	e2 f7       	brpl	.-8      	; 0x71fc <DIO_vidSetPinDir+0x9a>
    7204:	80 95       	com	r24
    7206:	82 23       	and	r24, r18
    7208:	84 bb       	out	0x14, r24	; 20
    720a:	08 95       	ret
			}
			else if (u8PinDir == OUTPUT)
    720c:	41 30       	cpi	r20, 0x01	; 1
    720e:	29 f5       	brne	.+74     	; 0x725a <DIO_vidSetPinDir+0xf8>
			{
				set_bit(DDRC_REGISTER , u8pinNo );
    7210:	24 b3       	in	r18, 0x14	; 20
    7212:	81 e0       	ldi	r24, 0x01	; 1
    7214:	90 e0       	ldi	r25, 0x00	; 0
    7216:	02 c0       	rjmp	.+4      	; 0x721c <DIO_vidSetPinDir+0xba>
    7218:	88 0f       	add	r24, r24
    721a:	99 1f       	adc	r25, r25
    721c:	6a 95       	dec	r22
    721e:	e2 f7       	brpl	.-8      	; 0x7218 <DIO_vidSetPinDir+0xb6>
    7220:	28 2b       	or	r18, r24
    7222:	24 bb       	out	0x14, r18	; 20
    7224:	08 95       	ret
			}

		}break;
		case PORTD :
		{
			if (u8PinDir == INPUT)
    7226:	44 23       	and	r20, r20
    7228:	61 f4       	brne	.+24     	; 0x7242 <DIO_vidSetPinDir+0xe0>
			{
				clr_bit(DDRD_REGISTER ,u8pinNo);
    722a:	21 b3       	in	r18, 0x11	; 17
    722c:	81 e0       	ldi	r24, 0x01	; 1
    722e:	90 e0       	ldi	r25, 0x00	; 0
    7230:	02 c0       	rjmp	.+4      	; 0x7236 <DIO_vidSetPinDir+0xd4>
    7232:	88 0f       	add	r24, r24
    7234:	99 1f       	adc	r25, r25
    7236:	6a 95       	dec	r22
    7238:	e2 f7       	brpl	.-8      	; 0x7232 <DIO_vidSetPinDir+0xd0>
    723a:	80 95       	com	r24
    723c:	82 23       	and	r24, r18
    723e:	81 bb       	out	0x11, r24	; 17
    7240:	08 95       	ret
			}
			else if (u8PinDir == OUTPUT)
    7242:	41 30       	cpi	r20, 0x01	; 1
    7244:	51 f4       	brne	.+20     	; 0x725a <DIO_vidSetPinDir+0xf8>
			{
				set_bit(DDRD_REGISTER , u8pinNo );
    7246:	21 b3       	in	r18, 0x11	; 17
    7248:	81 e0       	ldi	r24, 0x01	; 1
    724a:	90 e0       	ldi	r25, 0x00	; 0
    724c:	02 c0       	rjmp	.+4      	; 0x7252 <DIO_vidSetPinDir+0xf0>
    724e:	88 0f       	add	r24, r24
    7250:	99 1f       	adc	r25, r25
    7252:	6a 95       	dec	r22
    7254:	e2 f7       	brpl	.-8      	; 0x724e <DIO_vidSetPinDir+0xec>
    7256:	28 2b       	or	r18, r24
    7258:	21 bb       	out	0x11, r18	; 17
    725a:	08 95       	ret

0000725c <DIO_vidSetPortValue>:
}


void DIO_vidSetPortValue (u8 u8PortName , u8 u8PortValue)
{
	switch (u8PortName)
    725c:	82 30       	cpi	r24, 0x02	; 2
    725e:	61 f0       	breq	.+24     	; 0x7278 <DIO_vidSetPortValue+0x1c>
    7260:	83 30       	cpi	r24, 0x03	; 3
    7262:	18 f4       	brcc	.+6      	; 0x726a <DIO_vidSetPortValue+0xe>
    7264:	81 30       	cpi	r24, 0x01	; 1
    7266:	69 f4       	brne	.+26     	; 0x7282 <DIO_vidSetPortValue+0x26>
    7268:	05 c0       	rjmp	.+10     	; 0x7274 <DIO_vidSetPortValue+0x18>
    726a:	83 30       	cpi	r24, 0x03	; 3
    726c:	39 f0       	breq	.+14     	; 0x727c <DIO_vidSetPortValue+0x20>
    726e:	84 30       	cpi	r24, 0x04	; 4
    7270:	41 f4       	brne	.+16     	; 0x7282 <DIO_vidSetPortValue+0x26>
    7272:	06 c0       	rjmp	.+12     	; 0x7280 <DIO_vidSetPortValue+0x24>
	{
		case PORTA :
		{
			PORTA_REGISTER = u8PortValue;
    7274:	6b bb       	out	0x1b, r22	; 27
    7276:	08 95       	ret
		}break;

		case PORTB :
		{
			PORTB_REGISTER = u8PortValue;
    7278:	68 bb       	out	0x18, r22	; 24
    727a:	08 95       	ret
		}break ;

		case PORTC :
		{
			PORTC_REGISTER = u8PortValue;
    727c:	65 bb       	out	0x15, r22	; 21
    727e:	08 95       	ret
		}break ;

		case PORTD :
		{
			PORTD_REGISTER = u8PortValue;
    7280:	62 bb       	out	0x12, r22	; 18
    7282:	08 95       	ret

00007284 <DIO_vidSetPinValue>:



void DIO_vidSetPinValue (u8 u8portName , u8 u8pinNo , u8 u8pinValue)
{
	switch (u8portName)
    7284:	82 30       	cpi	r24, 0x02	; 2
    7286:	31 f1       	breq	.+76     	; 0x72d4 <DIO_vidSetPinValue+0x50>
    7288:	83 30       	cpi	r24, 0x03	; 3
    728a:	20 f4       	brcc	.+8      	; 0x7294 <DIO_vidSetPinValue+0x10>
    728c:	81 30       	cpi	r24, 0x01	; 1
    728e:	09 f0       	breq	.+2      	; 0x7292 <DIO_vidSetPinValue+0xe>
    7290:	6f c0       	rjmp	.+222    	; 0x7370 <DIO_vidSetPinValue+0xec>
    7292:	06 c0       	rjmp	.+12     	; 0x72a0 <DIO_vidSetPinValue+0x1c>
    7294:	83 30       	cpi	r24, 0x03	; 3
    7296:	c1 f1       	breq	.+112    	; 0x7308 <DIO_vidSetPinValue+0x84>
    7298:	84 30       	cpi	r24, 0x04	; 4
    729a:	09 f0       	breq	.+2      	; 0x729e <DIO_vidSetPinValue+0x1a>
    729c:	69 c0       	rjmp	.+210    	; 0x7370 <DIO_vidSetPinValue+0xec>
    729e:	4e c0       	rjmp	.+156    	; 0x733c <DIO_vidSetPinValue+0xb8>
	{
		case PORTA :
		{
			assign_bit(PORTA_REGISTER,u8pinNo,u8pinValue) ;
    72a0:	41 30       	cpi	r20, 0x01	; 1
    72a2:	59 f4       	brne	.+22     	; 0x72ba <DIO_vidSetPinValue+0x36>
    72a4:	2b b3       	in	r18, 0x1b	; 27
    72a6:	81 e0       	ldi	r24, 0x01	; 1
    72a8:	90 e0       	ldi	r25, 0x00	; 0
    72aa:	02 c0       	rjmp	.+4      	; 0x72b0 <DIO_vidSetPinValue+0x2c>
    72ac:	88 0f       	add	r24, r24
    72ae:	99 1f       	adc	r25, r25
    72b0:	6a 95       	dec	r22
    72b2:	e2 f7       	brpl	.-8      	; 0x72ac <DIO_vidSetPinValue+0x28>
    72b4:	28 2b       	or	r18, r24
    72b6:	2b bb       	out	0x1b, r18	; 27
    72b8:	0b c0       	rjmp	.+22     	; 0x72d0 <DIO_vidSetPinValue+0x4c>
    72ba:	2b b3       	in	r18, 0x1b	; 27
    72bc:	81 e0       	ldi	r24, 0x01	; 1
    72be:	90 e0       	ldi	r25, 0x00	; 0
    72c0:	02 c0       	rjmp	.+4      	; 0x72c6 <DIO_vidSetPinValue+0x42>
    72c2:	88 0f       	add	r24, r24
    72c4:	99 1f       	adc	r25, r25
    72c6:	6a 95       	dec	r22
    72c8:	e2 f7       	brpl	.-8      	; 0x72c2 <DIO_vidSetPinValue+0x3e>
    72ca:	80 95       	com	r24
    72cc:	82 23       	and	r24, r18
    72ce:	8b bb       	out	0x1b, r24	; 27
    72d0:	8b b3       	in	r24, 0x1b	; 27
    72d2:	08 95       	ret
		}break;

		case PORTB :
		{
			assign_bit(PORTB_REGISTER,u8pinNo,u8pinValue) ;
    72d4:	41 30       	cpi	r20, 0x01	; 1
    72d6:	59 f4       	brne	.+22     	; 0x72ee <DIO_vidSetPinValue+0x6a>
    72d8:	28 b3       	in	r18, 0x18	; 24
    72da:	81 e0       	ldi	r24, 0x01	; 1
    72dc:	90 e0       	ldi	r25, 0x00	; 0
    72de:	02 c0       	rjmp	.+4      	; 0x72e4 <DIO_vidSetPinValue+0x60>
    72e0:	88 0f       	add	r24, r24
    72e2:	99 1f       	adc	r25, r25
    72e4:	6a 95       	dec	r22
    72e6:	e2 f7       	brpl	.-8      	; 0x72e0 <DIO_vidSetPinValue+0x5c>
    72e8:	28 2b       	or	r18, r24
    72ea:	28 bb       	out	0x18, r18	; 24
    72ec:	0b c0       	rjmp	.+22     	; 0x7304 <DIO_vidSetPinValue+0x80>
    72ee:	28 b3       	in	r18, 0x18	; 24
    72f0:	81 e0       	ldi	r24, 0x01	; 1
    72f2:	90 e0       	ldi	r25, 0x00	; 0
    72f4:	02 c0       	rjmp	.+4      	; 0x72fa <DIO_vidSetPinValue+0x76>
    72f6:	88 0f       	add	r24, r24
    72f8:	99 1f       	adc	r25, r25
    72fa:	6a 95       	dec	r22
    72fc:	e2 f7       	brpl	.-8      	; 0x72f6 <DIO_vidSetPinValue+0x72>
    72fe:	80 95       	com	r24
    7300:	82 23       	and	r24, r18
    7302:	88 bb       	out	0x18, r24	; 24
    7304:	88 b3       	in	r24, 0x18	; 24
    7306:	08 95       	ret
		}break ;

		case PORTC :
		{
			assign_bit(PORTC_REGISTER,u8pinNo,u8pinValue) ;
    7308:	41 30       	cpi	r20, 0x01	; 1
    730a:	59 f4       	brne	.+22     	; 0x7322 <DIO_vidSetPinValue+0x9e>
    730c:	25 b3       	in	r18, 0x15	; 21
    730e:	81 e0       	ldi	r24, 0x01	; 1
    7310:	90 e0       	ldi	r25, 0x00	; 0
    7312:	02 c0       	rjmp	.+4      	; 0x7318 <DIO_vidSetPinValue+0x94>
    7314:	88 0f       	add	r24, r24
    7316:	99 1f       	adc	r25, r25
    7318:	6a 95       	dec	r22
    731a:	e2 f7       	brpl	.-8      	; 0x7314 <DIO_vidSetPinValue+0x90>
    731c:	28 2b       	or	r18, r24
    731e:	25 bb       	out	0x15, r18	; 21
    7320:	0b c0       	rjmp	.+22     	; 0x7338 <DIO_vidSetPinValue+0xb4>
    7322:	25 b3       	in	r18, 0x15	; 21
    7324:	81 e0       	ldi	r24, 0x01	; 1
    7326:	90 e0       	ldi	r25, 0x00	; 0
    7328:	02 c0       	rjmp	.+4      	; 0x732e <DIO_vidSetPinValue+0xaa>
    732a:	88 0f       	add	r24, r24
    732c:	99 1f       	adc	r25, r25
    732e:	6a 95       	dec	r22
    7330:	e2 f7       	brpl	.-8      	; 0x732a <DIO_vidSetPinValue+0xa6>
    7332:	80 95       	com	r24
    7334:	82 23       	and	r24, r18
    7336:	85 bb       	out	0x15, r24	; 21
    7338:	85 b3       	in	r24, 0x15	; 21
    733a:	08 95       	ret
		}break ;

		case PORTD :
		{
			assign_bit(PORTD_REGISTER,u8pinNo,u8pinValue) ;
    733c:	41 30       	cpi	r20, 0x01	; 1
    733e:	61 f4       	brne	.+24     	; 0x7358 <DIO_vidSetPinValue+0xd4>
    7340:	22 b3       	in	r18, 0x12	; 18
    7342:	81 e0       	ldi	r24, 0x01	; 1
    7344:	90 e0       	ldi	r25, 0x00	; 0
    7346:	02 c0       	rjmp	.+4      	; 0x734c <DIO_vidSetPinValue+0xc8>
    7348:	88 0f       	add	r24, r24
    734a:	99 1f       	adc	r25, r25
    734c:	6a 95       	dec	r22
    734e:	e2 f7       	brpl	.-8      	; 0x7348 <DIO_vidSetPinValue+0xc4>
    7350:	28 2b       	or	r18, r24
    7352:	22 bb       	out	0x12, r18	; 18
    7354:	82 b3       	in	r24, 0x12	; 18
    7356:	08 95       	ret
    7358:	22 b3       	in	r18, 0x12	; 18
    735a:	81 e0       	ldi	r24, 0x01	; 1
    735c:	90 e0       	ldi	r25, 0x00	; 0
    735e:	02 c0       	rjmp	.+4      	; 0x7364 <DIO_vidSetPinValue+0xe0>
    7360:	88 0f       	add	r24, r24
    7362:	99 1f       	adc	r25, r25
    7364:	6a 95       	dec	r22
    7366:	e2 f7       	brpl	.-8      	; 0x7360 <DIO_vidSetPinValue+0xdc>
    7368:	80 95       	com	r24
    736a:	82 23       	and	r24, r18
    736c:	82 bb       	out	0x12, r24	; 18
    736e:	82 b3       	in	r24, 0x12	; 18
    7370:	08 95       	ret

00007372 <DIO_vidGetPortValue>:


u8 DIO_vidGetPortValue(u8 u8PortName)
{
	u8 retVal ;
	switch(u8PortName)
    7372:	82 30       	cpi	r24, 0x02	; 2
    7374:	61 f0       	breq	.+24     	; 0x738e <DIO_vidGetPortValue+0x1c>
    7376:	83 30       	cpi	r24, 0x03	; 3
    7378:	18 f4       	brcc	.+6      	; 0x7380 <DIO_vidGetPortValue+0xe>
    737a:	81 30       	cpi	r24, 0x01	; 1
    737c:	69 f4       	brne	.+26     	; 0x7398 <DIO_vidGetPortValue+0x26>
    737e:	05 c0       	rjmp	.+10     	; 0x738a <DIO_vidGetPortValue+0x18>
    7380:	83 30       	cpi	r24, 0x03	; 3
    7382:	39 f0       	breq	.+14     	; 0x7392 <DIO_vidGetPortValue+0x20>
    7384:	84 30       	cpi	r24, 0x04	; 4
    7386:	41 f4       	brne	.+16     	; 0x7398 <DIO_vidGetPortValue+0x26>
    7388:	06 c0       	rjmp	.+12     	; 0x7396 <DIO_vidGetPortValue+0x24>
	{
		case PORTA:
		{
			retVal = PINA_REGISTER;
    738a:	89 b3       	in	r24, 0x19	; 25
    738c:	08 95       	ret
		}break ;

		case PORTB:
		{
			retVal = PINB_REGISTER;
    738e:	86 b3       	in	r24, 0x16	; 22
    7390:	08 95       	ret
		}break ;

		case PORTC:
		{
			retVal = PINC_REGISTER;
    7392:	83 b3       	in	r24, 0x13	; 19
    7394:	08 95       	ret
		}break ;

		case PORTD:
		{
			retVal = PIND_REGISTER;
    7396:	80 b3       	in	r24, 0x10	; 16
		}break ;
	}

	return retVal;
}
    7398:	08 95       	ret

0000739a <DIO_u8GetPinaValue>:


u8 DIO_u8GetPinaValue (u8 u8PortName , u8 u8PinNo )
{
	u8 Value ;
	switch (u8PortName)
    739a:	82 30       	cpi	r24, 0x02	; 2
    739c:	61 f0       	breq	.+24     	; 0x73b6 <DIO_u8GetPinaValue+0x1c>
    739e:	83 30       	cpi	r24, 0x03	; 3
    73a0:	18 f4       	brcc	.+6      	; 0x73a8 <DIO_u8GetPinaValue+0xe>
    73a2:	81 30       	cpi	r24, 0x01	; 1
    73a4:	d9 f4       	brne	.+54     	; 0x73dc <DIO_u8GetPinaValue+0x42>
    73a6:	05 c0       	rjmp	.+10     	; 0x73b2 <DIO_u8GetPinaValue+0x18>
    73a8:	83 30       	cpi	r24, 0x03	; 3
    73aa:	39 f0       	breq	.+14     	; 0x73ba <DIO_u8GetPinaValue+0x20>
    73ac:	84 30       	cpi	r24, 0x04	; 4
    73ae:	b1 f4       	brne	.+44     	; 0x73dc <DIO_u8GetPinaValue+0x42>
    73b0:	0d c0       	rjmp	.+26     	; 0x73cc <DIO_u8GetPinaValue+0x32>
	{
		case PORTA :
		{
			Value =  get_bit(PINA_REGISTER, u8PinNo);
    73b2:	89 b3       	in	r24, 0x19	; 25
    73b4:	03 c0       	rjmp	.+6      	; 0x73bc <DIO_u8GetPinaValue+0x22>
		}break ;
		case PORTB :
		{
			Value =  get_bit(PINB_REGISTER, u8PinNo);
    73b6:	86 b3       	in	r24, 0x16	; 22
    73b8:	01 c0       	rjmp	.+2      	; 0x73bc <DIO_u8GetPinaValue+0x22>
		}break ;
		case PORTC :
		{
			Value =  get_bit(PINC_REGISTER, u8PinNo);
    73ba:	83 b3       	in	r24, 0x13	; 19
    73bc:	90 e0       	ldi	r25, 0x00	; 0
    73be:	02 c0       	rjmp	.+4      	; 0x73c4 <DIO_u8GetPinaValue+0x2a>
    73c0:	95 95       	asr	r25
    73c2:	87 95       	ror	r24
    73c4:	6a 95       	dec	r22
    73c6:	e2 f7       	brpl	.-8      	; 0x73c0 <DIO_u8GetPinaValue+0x26>
    73c8:	81 70       	andi	r24, 0x01	; 1
    73ca:	08 95       	ret
		}break ;

		case PORTD :
		{
			Value =  get_bit(PIND_REGISTER, u8PinNo);
    73cc:	80 b3       	in	r24, 0x10	; 16
    73ce:	90 e0       	ldi	r25, 0x00	; 0
    73d0:	02 c0       	rjmp	.+4      	; 0x73d6 <DIO_u8GetPinaValue+0x3c>
    73d2:	95 95       	asr	r25
    73d4:	87 95       	ror	r24
    73d6:	6a 95       	dec	r22
    73d8:	e2 f7       	brpl	.-8      	; 0x73d2 <DIO_u8GetPinaValue+0x38>
    73da:	81 70       	andi	r24, 0x01	; 1
		}break ;
	}

	return Value ;
}
    73dc:	08 95       	ret

000073de <boot_program_page>:
static u8 u8ReqLen;
static u8 *pu8ReqData ;
static downloadStates enuDownloadState;

void boot_program_page (uint16_t page, uint8_t *buf)
{
    73de:	0f 93       	push	r16
    73e0:	1f 93       	push	r17
    73e2:	cf 93       	push	r28
    73e4:	df 93       	push	r29
    73e6:	ec 01       	movw	r28, r24
    73e8:	db 01       	movw	r26, r22
	uint8_t sreg;
	uint32_t address;
	uint16_t word ;

	// Disable interrupts.
	sreg = SREG;
    73ea:	7f b7       	in	r23, 0x3f	; 63
	asm("cli");
    73ec:	f8 94       	cli
	address = page * SPM_PAGESIZE ;
    73ee:	d6 95       	lsr	r29
    73f0:	dc 2f       	mov	r29, r28
    73f2:	cc 27       	eor	r28, r28
    73f4:	d7 95       	ror	r29
    73f6:	c7 95       	ror	r28

	boot_page_erase_safe (address);
    73f8:	07 b6       	in	r0, 0x37	; 55
    73fa:	00 fc       	sbrc	r0, 0
    73fc:	fd cf       	rjmp	.-6      	; 0x73f8 <boot_program_page+0x1a>
    73fe:	e1 99       	sbic	0x1c, 1	; 28
    7400:	fe cf       	rjmp	.-4      	; 0x73fe <boot_program_page+0x20>
    7402:	83 e0       	ldi	r24, 0x03	; 3
    7404:	fe 01       	movw	r30, r28
    7406:	80 93 57 00 	sts	0x0057, r24
    740a:	e8 95       	spm
    740c:	40 e0       	ldi	r20, 0x00	; 0
    740e:	50 e0       	ldi	r21, 0x00	; 0
	{
		// Set up little Endian word.
		word  = *buf++;
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
    7410:	61 e0       	ldi	r22, 0x01	; 1
	boot_page_erase_safe (address);

	for (i=0; i<SPM_PAGESIZE; i+=2)
	{
		// Set up little Endian word.
		word  = *buf++;
    7412:	9c 91       	ld	r25, X
		word += (*buf++) << 8;
    7414:	11 96       	adiw	r26, 0x01	; 1
    7416:	8c 91       	ld	r24, X
    7418:	11 97       	sbiw	r26, 0x01	; 1
static u8 u8ReqLen;
static u8 *pu8ReqData ;
static downloadStates enuDownloadState;

void boot_program_page (uint16_t page, uint8_t *buf)
{
    741a:	12 96       	adiw	r26, 0x02	; 2
	{
		// Set up little Endian word.
		word  = *buf++;
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
    741c:	07 b6       	in	r0, 0x37	; 55
    741e:	00 fc       	sbrc	r0, 0
    7420:	fd cf       	rjmp	.-6      	; 0x741c <boot_program_page+0x3e>
    7422:	e1 99       	sbic	0x1c, 1	; 28
    7424:	fe cf       	rjmp	.-4      	; 0x7422 <boot_program_page+0x44>
    7426:	fa 01       	movw	r30, r20
    7428:	ec 0f       	add	r30, r28
    742a:	fd 1f       	adc	r31, r29
    742c:	38 2f       	mov	r19, r24
    742e:	20 e0       	ldi	r18, 0x00	; 0
    7430:	89 01       	movw	r16, r18
    7432:	09 0f       	add	r16, r25
    7434:	11 1d       	adc	r17, r1
    7436:	08 01       	movw	r0, r16
    7438:	60 93 57 00 	sts	0x0057, r22
    743c:	e8 95       	spm
    743e:	11 24       	eor	r1, r1
	asm("cli");
	address = page * SPM_PAGESIZE ;

	boot_page_erase_safe (address);

	for (i=0; i<SPM_PAGESIZE; i+=2)
    7440:	4e 5f       	subi	r20, 0xFE	; 254
    7442:	5f 4f       	sbci	r21, 0xFF	; 255
    7444:	40 38       	cpi	r20, 0x80	; 128
    7446:	51 05       	cpc	r21, r1
    7448:	21 f7       	brne	.-56     	; 0x7412 <boot_program_page+0x34>
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
	}

	boot_page_write_safe (address);     // Store buffer in flash page.
    744a:	07 b6       	in	r0, 0x37	; 55
    744c:	00 fc       	sbrc	r0, 0
    744e:	fd cf       	rjmp	.-6      	; 0x744a <boot_program_page+0x6c>
    7450:	e1 99       	sbic	0x1c, 1	; 28
    7452:	fe cf       	rjmp	.-4      	; 0x7450 <boot_program_page+0x72>
    7454:	85 e0       	ldi	r24, 0x05	; 5
    7456:	fe 01       	movw	r30, r28
    7458:	80 93 57 00 	sts	0x0057, r24
    745c:	e8 95       	spm

	// Reenable RWW-section again. We need this if we want to jump back
	// to the application after bootloading.

	boot_rww_enable_safe();
    745e:	07 b6       	in	r0, 0x37	; 55
    7460:	00 fc       	sbrc	r0, 0
    7462:	fd cf       	rjmp	.-6      	; 0x745e <boot_program_page+0x80>
    7464:	e1 99       	sbic	0x1c, 1	; 28
    7466:	fe cf       	rjmp	.-4      	; 0x7464 <boot_program_page+0x86>
    7468:	81 e1       	ldi	r24, 0x11	; 17
    746a:	80 93 57 00 	sts	0x0057, r24
    746e:	e8 95       	spm

	// Re-enable interrupts (if they were ever enabled).

	SREG = sreg;
    7470:	7f bf       	out	0x3f, r23	; 63
}
    7472:	df 91       	pop	r29
    7474:	cf 91       	pop	r28
    7476:	1f 91       	pop	r17
    7478:	0f 91       	pop	r16
    747a:	08 95       	ret

0000747c <flashing_vidRxNotification>:



extern void flashing_vidRxNotification(u8* pu8Data , u8 u8len)
{
	bIsRequestReceived = TRUE ;
    747c:	21 e0       	ldi	r18, 0x01	; 1
    747e:	20 93 60 00 	sts	0x0060, r18
	u8SID = pu8Data[0];
    7482:	fc 01       	movw	r30, r24
    7484:	81 91       	ld	r24, Z+
    7486:	80 93 66 00 	sts	0x0066, r24
	pu8ReqData = &pu8Data[1] ;
    748a:	f0 93 69 00 	sts	0x0069, r31
    748e:	e0 93 68 00 	sts	0x0068, r30
	u8ReqLen = u8len ;
    7492:	60 93 67 00 	sts	0x0067, r22
}
    7496:	08 95       	ret

00007498 <flashingMngr_vidHandleReqFromApp>:


void flashingMngr_vidHandleReqFromApp(void)
{
	/*Programming session has been sent to Application [Reprogramming request]*/
	u8SID = 0x10 ;
    7498:	80 e1       	ldi	r24, 0x10	; 16
    749a:	80 93 66 00 	sts	0x0066, r24
	UART_SendChar(0x7F) ;
}

void LOC_vidSendPosResp(void)
{
	UART_SendChar(u8SID + 0x40);
    749e:	80 e5       	ldi	r24, 0x50	; 80
    74a0:	0e 94 56 3b 	call	0x76ac	; 0x76ac <UART_SendChar>
void flashingMngr_vidHandleReqFromApp(void)
{
	/*Programming session has been sent to Application [Reprogramming request]*/
	u8SID = 0x10 ;
	LOC_vidSendPosResp();
	enuDownloadState = waiting_DownloadRequest ;
    74a4:	81 e0       	ldi	r24, 0x01	; 1
    74a6:	80 93 6a 00 	sts	0x006A, r24
}
    74aa:	08 95       	ret

000074ac <flashingMngr_vidMainTask>:
	static u16 u16CodeSize , u16ReceivedLen = 0 ;
	static u8 u8PageNo = 0 ;
	boolean bValidReq = FALSE, bValidCRC ;
	u16 u16ReceivedCRC ;

	if(bIsRequestReceived)
    74ac:	80 91 60 00 	lds	r24, 0x0060
    74b0:	88 23       	and	r24, r24
    74b2:	09 f4       	brne	.+2      	; 0x74b6 <flashingMngr_vidMainTask+0xa>
    74b4:	f0 c0       	rjmp	.+480    	; 0x7696 <flashingMngr_vidMainTask+0x1ea>
	{
		switch(u8SID)
    74b6:	80 91 66 00 	lds	r24, 0x0066
    74ba:	84 33       	cpi	r24, 0x34	; 52
    74bc:	31 f1       	breq	.+76     	; 0x750a <flashingMngr_vidMainTask+0x5e>
    74be:	85 33       	cpi	r24, 0x35	; 53
    74c0:	30 f4       	brcc	.+12     	; 0x74ce <flashingMngr_vidMainTask+0x22>
    74c2:	80 31       	cpi	r24, 0x10	; 16
    74c4:	59 f0       	breq	.+22     	; 0x74dc <flashingMngr_vidMainTask+0x30>
    74c6:	81 33       	cpi	r24, 0x31	; 49
    74c8:	09 f0       	breq	.+2      	; 0x74cc <flashingMngr_vidMainTask+0x20>
    74ca:	cd c0       	rjmp	.+410    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
    74cc:	7f c0       	rjmp	.+254    	; 0x75cc <flashingMngr_vidMainTask+0x120>
    74ce:	86 33       	cpi	r24, 0x36	; 54
    74d0:	09 f4       	brne	.+2      	; 0x74d4 <flashingMngr_vidMainTask+0x28>
    74d2:	3e c0       	rjmp	.+124    	; 0x7550 <flashingMngr_vidMainTask+0xa4>
    74d4:	87 33       	cpi	r24, 0x37	; 55
    74d6:	09 f0       	breq	.+2      	; 0x74da <flashingMngr_vidMainTask+0x2e>
    74d8:	c6 c0       	rjmp	.+396    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
    74da:	69 c0       	rjmp	.+210    	; 0x75ae <flashingMngr_vidMainTask+0x102>
		{
			case SESSION_CONTROL:
			{
				if(pu8ReqData[0] == PROGRAMMING_SESSION && (u8ReqLen == 2) &&
    74dc:	e0 91 68 00 	lds	r30, 0x0068
    74e0:	f0 91 69 00 	lds	r31, 0x0069
    74e4:	80 81       	ld	r24, Z
    74e6:	83 30       	cpi	r24, 0x03	; 3
    74e8:	09 f0       	breq	.+2      	; 0x74ec <flashingMngr_vidMainTask+0x40>
    74ea:	bd c0       	rjmp	.+378    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
    74ec:	80 91 67 00 	lds	r24, 0x0067
    74f0:	82 30       	cpi	r24, 0x02	; 2
    74f2:	09 f0       	breq	.+2      	; 0x74f6 <flashingMngr_vidMainTask+0x4a>
    74f4:	b8 c0       	rjmp	.+368    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
    74f6:	80 91 6a 00 	lds	r24, 0x006A
    74fa:	88 23       	and	r24, r24
    74fc:	09 f0       	breq	.+2      	; 0x7500 <flashingMngr_vidMainTask+0x54>
    74fe:	b3 c0       	rjmp	.+358    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
	UART_SendChar(0x7F) ;
}

void LOC_vidSendPosResp(void)
{
	UART_SendChar(u8SID + 0x40);
    7500:	80 e5       	ldi	r24, 0x50	; 80
    7502:	0e 94 56 3b 	call	0x76ac	; 0x76ac <UART_SendChar>
				if(pu8ReqData[0] == PROGRAMMING_SESSION && (u8ReqLen == 2) &&
						(enuDownloadState ==waiting_ProgrammingSession ))
				{
					/*Programming session, Valid request*/
					LOC_vidSendPosResp();
					enuDownloadState = waiting_DownloadRequest ;
    7506:	81 e0       	ldi	r24, 0x01	; 1
    7508:	20 c0       	rjmp	.+64     	; 0x754a <flashingMngr_vidMainTask+0x9e>
				}
			}break;

			case DOWNLOAD_REQUEST:
			{
				if((enuDownloadState == waiting_DownloadRequest) &&
    750a:	80 91 6a 00 	lds	r24, 0x006A
    750e:	81 30       	cpi	r24, 0x01	; 1
    7510:	09 f0       	breq	.+2      	; 0x7514 <flashingMngr_vidMainTask+0x68>
    7512:	a9 c0       	rjmp	.+338    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
    7514:	80 91 67 00 	lds	r24, 0x0067
    7518:	83 30       	cpi	r24, 0x03	; 3
    751a:	09 f0       	breq	.+2      	; 0x751e <flashingMngr_vidMainTask+0x72>
    751c:	a4 c0       	rjmp	.+328    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
						(u8ReqLen == 3))
				{
					/*Valid request*/
					/*Big endian 2 bytes code size*/
					u16CodeSize = pu8ReqData[0]<<8 | pu8ReqData[1] ;
    751e:	e0 91 68 00 	lds	r30, 0x0068
    7522:	f0 91 69 00 	lds	r31, 0x0069
    7526:	21 81       	ldd	r18, Z+1	; 0x01
    7528:	30 e0       	ldi	r19, 0x00	; 0
    752a:	90 81       	ld	r25, Z
    752c:	80 e0       	ldi	r24, 0x00	; 0
    752e:	28 2b       	or	r18, r24
    7530:	39 2b       	or	r19, r25
    7532:	30 93 65 00 	sts	0x0065, r19
    7536:	20 93 64 00 	sts	0x0064, r18
					if(u16CodeSize < MAX_CODE_SIZE)
    753a:	20 50       	subi	r18, 0x00	; 0
    753c:	38 43       	sbci	r19, 0x38	; 56
    753e:	08 f0       	brcs	.+2      	; 0x7542 <flashingMngr_vidMainTask+0x96>
    7540:	92 c0       	rjmp	.+292    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
	UART_SendChar(0x7F) ;
}

void LOC_vidSendPosResp(void)
{
	UART_SendChar(u8SID + 0x40);
    7542:	84 e7       	ldi	r24, 0x74	; 116
    7544:	0e 94 56 3b 	call	0x76ac	; 0x76ac <UART_SendChar>
					/*Big endian 2 bytes code size*/
					u16CodeSize = pu8ReqData[0]<<8 | pu8ReqData[1] ;
					if(u16CodeSize < MAX_CODE_SIZE)
					{
						LOC_vidSendPosResp();
						enuDownloadState = waiting_TransferData ;
    7548:	82 e0       	ldi	r24, 0x02	; 2
    754a:	80 93 6a 00 	sts	0x006A, r24
    754e:	90 c0       	rjmp	.+288    	; 0x7670 <flashingMngr_vidMainTask+0x1c4>
				}
			}break;

			case TRANSFER_DATA:
			{
				if((enuDownloadState ==waiting_TransferData) &&
    7550:	80 91 6a 00 	lds	r24, 0x006A
    7554:	82 30       	cpi	r24, 0x02	; 2
    7556:	09 f0       	breq	.+2      	; 0x755a <flashingMngr_vidMainTask+0xae>
    7558:	86 c0       	rjmp	.+268    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
    755a:	80 91 67 00 	lds	r24, 0x0067
    755e:	81 38       	cpi	r24, 0x81	; 129
    7560:	09 f0       	breq	.+2      	; 0x7564 <flashingMngr_vidMainTask+0xb8>
    7562:	81 c0       	rjmp	.+258    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
						(u8ReqLen == PAGE_SIZE+1))
				{
					/*Write flash page, starting from index 1 [neglect SID] */
					boot_program_page(u8PageNo ,&pu8ReqData[0]);
    7564:	60 91 68 00 	lds	r22, 0x0068
    7568:	70 91 69 00 	lds	r23, 0x0069
    756c:	80 91 61 00 	lds	r24, 0x0061
    7570:	90 e0       	ldi	r25, 0x00	; 0
    7572:	0e 94 ef 39 	call	0x73de	; 0x73de <boot_program_page>
	UART_SendChar(0x7F) ;
}

void LOC_vidSendPosResp(void)
{
	UART_SendChar(u8SID + 0x40);
    7576:	86 e7       	ldi	r24, 0x76	; 118
    7578:	0e 94 56 3b 	call	0x76ac	; 0x76ac <UART_SendChar>
						(u8ReqLen == PAGE_SIZE+1))
				{
					/*Write flash page, starting from index 1 [neglect SID] */
					boot_program_page(u8PageNo ,&pu8ReqData[0]);
					LOC_vidSendPosResp();
					u8PageNo ++ ;
    757c:	80 91 61 00 	lds	r24, 0x0061
    7580:	8f 5f       	subi	r24, 0xFF	; 255
    7582:	80 93 61 00 	sts	0x0061, r24
					u16ReceivedLen += PAGE_SIZE ;
    7586:	80 91 62 00 	lds	r24, 0x0062
    758a:	90 91 63 00 	lds	r25, 0x0063
    758e:	80 58       	subi	r24, 0x80	; 128
    7590:	9f 4f       	sbci	r25, 0xFF	; 255
    7592:	90 93 63 00 	sts	0x0063, r25
    7596:	80 93 62 00 	sts	0x0062, r24
					if(u16ReceivedLen == u16CodeSize)
    759a:	20 91 64 00 	lds	r18, 0x0064
    759e:	30 91 65 00 	lds	r19, 0x0065
    75a2:	82 17       	cp	r24, r18
    75a4:	93 07       	cpc	r25, r19
    75a6:	09 f0       	breq	.+2      	; 0x75aa <flashingMngr_vidMainTask+0xfe>
    75a8:	63 c0       	rjmp	.+198    	; 0x7670 <flashingMngr_vidMainTask+0x1c4>
					{
						/*Download is Done*/
						enuDownloadState = waiting_TransferExit;
    75aa:	83 e0       	ldi	r24, 0x03	; 3
    75ac:	ce cf       	rjmp	.-100    	; 0x754a <flashingMngr_vidMainTask+0x9e>
					/*TODO: specify NRC*/
				}
			}break;
			case TRANSFER_EXIT:
			{
				if((enuDownloadState == waiting_TransferExit) &&
    75ae:	80 91 6a 00 	lds	r24, 0x006A
    75b2:	83 30       	cpi	r24, 0x03	; 3
    75b4:	09 f0       	breq	.+2      	; 0x75b8 <flashingMngr_vidMainTask+0x10c>
    75b6:	57 c0       	rjmp	.+174    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
    75b8:	80 91 67 00 	lds	r24, 0x0067
    75bc:	81 30       	cpi	r24, 0x01	; 1
    75be:	09 f0       	breq	.+2      	; 0x75c2 <flashingMngr_vidMainTask+0x116>
    75c0:	52 c0       	rjmp	.+164    	; 0x7666 <flashingMngr_vidMainTask+0x1ba>
	UART_SendChar(0x7F) ;
}

void LOC_vidSendPosResp(void)
{
	UART_SendChar(u8SID + 0x40);
    75c2:	87 e7       	ldi	r24, 0x77	; 119
    75c4:	0e 94 56 3b 	call	0x76ac	; 0x76ac <UART_SendChar>
			{
				if((enuDownloadState == waiting_TransferExit) &&
									(u8ReqLen == 1))
				{
					LOC_vidSendPosResp();
					enuDownloadState = waiting_CheckCRC;
    75c8:	84 e0       	ldi	r24, 0x04	; 4
    75ca:	bf cf       	rjmp	.-130    	; 0x754a <flashingMngr_vidMainTask+0x9e>
					/*TODO: specify NRC*/
				}
			}break;
			case CHECK_CRC:
			{
				if((enuDownloadState == waiting_CheckCRC) &&
    75cc:	80 91 6a 00 	lds	r24, 0x006A
    75d0:	84 30       	cpi	r24, 0x04	; 4
    75d2:	09 f0       	breq	.+2      	; 0x75d6 <flashingMngr_vidMainTask+0x12a>
    75d4:	42 c0       	rjmp	.+132    	; 0x765a <flashingMngr_vidMainTask+0x1ae>
    75d6:	80 91 67 00 	lds	r24, 0x0067
    75da:	83 30       	cpi	r24, 0x03	; 3
    75dc:	09 f0       	breq	.+2      	; 0x75e0 <flashingMngr_vidMainTask+0x134>
    75de:	3d c0       	rjmp	.+122    	; 0x765a <flashingMngr_vidMainTask+0x1ae>
									(u8ReqLen == 3))
				{
					u16ReceivedCRC = pu8ReqData[0]<<8 | pu8ReqData[1] ;
    75e0:	e0 91 68 00 	lds	r30, 0x0068
    75e4:	f0 91 69 00 	lds	r31, 0x0069
    75e8:	a0 81       	ld	r26, Z
    75ea:	21 81       	ldd	r18, Z+1	; 0x01
					/*Validate CRC of flashed code, in range of 0~codeSize*/
					bValidCRC = LOC_vidCheckFlashCRC(0, u16CodeSize, u16ReceivedCRC);
    75ec:	60 91 64 00 	lds	r22, 0x0064
    75f0:	70 91 65 00 	lds	r23, 0x0065
    75f4:	4f ef       	ldi	r20, 0xFF	; 255
    75f6:	5f ef       	ldi	r21, 0xFF	; 255
    75f8:	e0 e0       	ldi	r30, 0x00	; 0
    75fa:	f0 e0       	ldi	r31, 0x00	; 0
    75fc:	19 c0       	rjmp	.+50     	; 0x7630 <flashingMngr_vidMainTask+0x184>
    u16 CRC16 = 0xFFFF ;

    /* Compute the CRC */
    for(addr = u16StartAdd; addr < u16EndAdd; addr++)
    {
    	u8Byte = pgm_read_byte(addr);
    75fe:	84 91       	lpm	r24, Z+
_crc16_update(uint16_t __crc, uint8_t __data)
{
	uint8_t __tmp;
	uint16_t __ret;

	__asm__ __volatile__ (
    7600:	48 27       	eor	r20, r24
    7602:	84 2f       	mov	r24, r20
    7604:	82 95       	swap	r24
    7606:	84 27       	eor	r24, r20
    7608:	08 2e       	mov	r0, r24
    760a:	86 95       	lsr	r24
    760c:	86 95       	lsr	r24
    760e:	80 25       	eor	r24, r0
    7610:	08 2e       	mov	r0, r24
    7612:	86 95       	lsr	r24
    7614:	80 25       	eor	r24, r0
    7616:	87 70       	andi	r24, 0x07	; 7
    7618:	04 2e       	mov	r0, r20
    761a:	45 2f       	mov	r20, r21
    761c:	86 95       	lsr	r24
    761e:	07 94       	ror	r0
    7620:	87 95       	ror	r24
    7622:	50 2d       	mov	r21, r0
    7624:	48 27       	eor	r20, r24
    7626:	06 94       	lsr	r0
    7628:	87 95       	ror	r24
    762a:	50 25       	eor	r21, r0
    762c:	48 27       	eor	r20, r24
    u16 addr;
    u8  u8Byte;
    u16 CRC16 = 0xFFFF ;

    /* Compute the CRC */
    for(addr = u16StartAdd; addr < u16EndAdd; addr++)
    762e:	31 96       	adiw	r30, 0x01	; 1
    7630:	e6 17       	cp	r30, r22
    7632:	f7 07       	cpc	r31, r23
    7634:	20 f3       	brcs	.-56     	; 0x75fe <flashingMngr_vidMainTask+0x152>
    	u8Byte = pgm_read_byte(addr);
      CRC16 = _crc16_update(CRC16, u8Byte);
    }

    /*Compare calculated CRC with received one*/
    if(u16CRC != CRC16 )
    7636:	30 e0       	ldi	r19, 0x00	; 0
    7638:	9a 2f       	mov	r25, r26
    763a:	80 e0       	ldi	r24, 0x00	; 0
    763c:	28 2b       	or	r18, r24
    763e:	39 2b       	or	r19, r25
    7640:	24 17       	cp	r18, r20
    7642:	35 07       	cpc	r19, r21
    7644:	51 f4       	brne	.+20     	; 0x765a <flashingMngr_vidMainTask+0x1ae>
    7646:	17 c0       	rjmp	.+46     	; 0x7676 <flashingMngr_vidMainTask+0x1ca>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7648:	ca 01       	movw	r24, r20
    764a:	01 97       	sbiw	r24, 0x01	; 1
    764c:	f1 f7       	brne	.-4      	; 0x764a <flashingMngr_vidMainTask+0x19e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    764e:	21 50       	subi	r18, 0x01	; 1
    7650:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7652:	d1 f7       	brne	.-12     	; 0x7648 <flashingMngr_vidMainTask+0x19c>
						/*Move vector Table to Application section*/
						APP_vidMoveIVT(APP_SECTION);
#endif
						_delay_ms(100) ;
						/*start the actual program*/
						asm("jmp 0");
    7654:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
    7658:	03 c0       	rjmp	.+6      	; 0x7660 <flashingMngr_vidMainTask+0x1b4>


void LOC_vidSendNegResp(void)
{
	/*TODO : handle NRCs*/
	UART_SendChar(0x7F) ;
    765a:	8f e7       	ldi	r24, 0x7F	; 127
    765c:	0e 94 56 3b 	call	0x76ac	; 0x76ac <UART_SendChar>
					/*Invalid request, or sequence error*/
					LOC_vidSendNegResp();
					/*TODO: specify NRC*/
				}

				enuDownloadState = waiting_ProgrammingSession;
    7660:	10 92 6a 00 	sts	0x006A, r1
    7664:	05 c0       	rjmp	.+10     	; 0x7670 <flashingMngr_vidMainTask+0x1c4>
			default:
			{
				/*Unknown SID*/
				/*Invalid request, or sequence error*/
				/*Reset download state*/
				enuDownloadState = waiting_ProgrammingSession ;
    7666:	10 92 6a 00 	sts	0x006A, r1


void LOC_vidSendNegResp(void)
{
	/*TODO : handle NRCs*/
	UART_SendChar(0x7F) ;
    766a:	8f e7       	ldi	r24, 0x7F	; 127
    766c:	0e 94 56 3b 	call	0x76ac	; 0x76ac <UART_SendChar>
				enuDownloadState = waiting_ProgrammingSession ;
				LOC_vidSendNegResp();
				/*TODO: specify NRC*/
			}
		}
		bIsRequestReceived = FALSE ;
    7670:	10 92 60 00 	sts	0x0060, r1
    7674:	08 95       	ret
	UART_SendChar(0x7F) ;
}

void LOC_vidSendPosResp(void)
{
	UART_SendChar(u8SID + 0x40);
    7676:	81 e7       	ldi	r24, 0x71	; 113
    7678:	0e 94 56 3b 	call	0x76ac	; 0x76ac <UART_SendChar>
					bValidCRC = LOC_vidCheckFlashCRC(0, u16CodeSize, u16ReceivedCRC);
					if(bValidCRC)
					{
						LOC_vidSendPosResp();
						/*Mark application as Valid*/
						eeprom_update_byte (VALID_APP_ADDRESS, 1);
    767c:	80 e0       	ldi	r24, 0x00	; 0
    767e:	90 e0       	ldi	r25, 0x00	; 0
    7680:	61 e0       	ldi	r22, 0x01	; 1
    7682:	0e 94 ac 3b 	call	0x7758	; 0x7758 <__eeupd_byte_m32>
#if USE_INTERRUPT ==1
						/*Move vector Table to Application section*/
						APP_vidMoveIVT(APP_SECTION);
    7686:	80 e0       	ldi	r24, 0x00	; 0
    7688:	0e 94 3e 38 	call	0x707c	; 0x707c <APP_vidMoveIVT>
    768c:	28 ee       	ldi	r18, 0xE8	; 232
    768e:	33 e0       	ldi	r19, 0x03	; 3
    7690:	4c e2       	ldi	r20, 0x2C	; 44
    7692:	51 e0       	ldi	r21, 0x01	; 1
    7694:	d9 cf       	rjmp	.-78     	; 0x7648 <flashingMngr_vidMainTask+0x19c>
    7696:	08 95       	ret

00007698 <UART_Init>:
u8 au8RxBuffer[255] ;

void UART_Init(void)
{
  // Set BaudRate -> 9600/12MhZ
  UBRRL_REGISTER = 77;
    7698:	8d e4       	ldi	r24, 0x4D	; 77
    769a:	89 b9       	out	0x09, r24	; 9
  UBRRH_REGISTER = 0;
    769c:	10 bc       	out	0x20, r1	; 32
  // Set Frame Format -> 8 data, 1 stop, No Parity
  UCSRC_REGISTER = 0x86;
    769e:	86 e8       	ldi	r24, 0x86	; 134
    76a0:	80 bd       	out	0x20, r24	; 32
  // Enable RX and TX and Rx interrupt
  UCSRB_REGISTER = 0x18;
    76a2:	88 e1       	ldi	r24, 0x18	; 24
    76a4:	8a b9       	out	0x0a, r24	; 10

#if USE_INTERRUPT == 1
  UCSRB_REGISTER |= 0x80 ;
    76a6:	57 9a       	sbi	0x0a, 7	; 10
  /*Enable Global interrupt*/
  asm("sei");
    76a8:	78 94       	sei
#endif

}
    76aa:	08 95       	ret

000076ac <UART_SendChar>:

void UART_SendChar(u8 data)
{

  // Wait until transmission Register Empty
  while((UCSRA_REGISTER&0x20) == 0x00);
    76ac:	5d 9b       	sbis	0x0b, 5	; 11
    76ae:	fe cf       	rjmp	.-4      	; 0x76ac <UART_SendChar>
  UDR_REGISTER = data;
    76b0:	8c b9       	out	0x0c, r24	; 12

}
    76b2:	08 95       	ret

000076b4 <UART_GetChar>:

u8 UART_GetChar(void)
{
  u8 Result;
  // Wait until Reception Complete
  while((UCSRA_REGISTER&0x80) == 0x00);
    76b4:	5f 9b       	sbis	0x0b, 7	; 11
    76b6:	fe cf       	rjmp	.-4      	; 0x76b4 <UART_GetChar>
  Result = UDR_REGISTER;
    76b8:	8c b1       	in	r24, 0x0c	; 12
  
  /* Clear Flag */
  set_bit(UCSRA_REGISTER,7);
    76ba:	5f 9a       	sbi	0x0b, 7	; 11
  return Result;
}
    76bc:	08 95       	ret

000076be <__vector_13>:

#if USE_INTERRUPT == 1
ISR(UART_RX_COMPLETE)
{
    76be:	1f 92       	push	r1
    76c0:	0f 92       	push	r0
    76c2:	0f b6       	in	r0, 0x3f	; 63
    76c4:	0f 92       	push	r0
    76c6:	11 24       	eor	r1, r1
    76c8:	2f 93       	push	r18
    76ca:	3f 93       	push	r19
    76cc:	4f 93       	push	r20
    76ce:	5f 93       	push	r21
    76d0:	6f 93       	push	r22
    76d2:	7f 93       	push	r23
    76d4:	8f 93       	push	r24
    76d6:	9f 93       	push	r25
    76d8:	af 93       	push	r26
    76da:	bf 93       	push	r27
    76dc:	ef 93       	push	r30
    76de:	ff 93       	push	r31
	static u8 RxState = IDLE ;
	static u8 bufferIdx = 0 ;

	if(RxState == IDLE)
    76e0:	80 91 6c 00 	lds	r24, 0x006C
    76e4:	88 23       	and	r24, r24
    76e6:	39 f4       	brne	.+14     	; 0x76f6 <__vector_13+0x38>
	{
		u8len = UDR_REGISTER ;
    76e8:	8c b1       	in	r24, 0x0c	; 12
    76ea:	80 93 6c 01 	sts	0x016C, r24
		RxState = RUNNING ;
    76ee:	81 e0       	ldi	r24, 0x01	; 1
    76f0:	80 93 6c 00 	sts	0x006C, r24
    76f4:	18 c0       	rjmp	.+48     	; 0x7726 <__vector_13+0x68>
	}
	else
	{
		au8RxBuffer[bufferIdx] = UDR_REGISTER ;
    76f6:	90 91 6b 00 	lds	r25, 0x006B
    76fa:	8c b1       	in	r24, 0x0c	; 12
    76fc:	e9 2f       	mov	r30, r25
    76fe:	f0 e0       	ldi	r31, 0x00	; 0
    7700:	e3 59       	subi	r30, 0x93	; 147
    7702:	ff 4f       	sbci	r31, 0xFF	; 255
    7704:	80 83       	st	Z, r24
		bufferIdx ++ ;
    7706:	69 2f       	mov	r22, r25
    7708:	6f 5f       	subi	r22, 0xFF	; 255
    770a:	60 93 6b 00 	sts	0x006B, r22
		if(bufferIdx == u8len)
    770e:	80 91 6c 01 	lds	r24, 0x016C
    7712:	68 17       	cp	r22, r24
    7714:	41 f4       	brne	.+16     	; 0x7726 <__vector_13+0x68>
		{
			/*all data is received */
			bufferIdx = 0 ;
    7716:	10 92 6b 00 	sts	0x006B, r1
			RxState = IDLE ;
    771a:	10 92 6c 00 	sts	0x006C, r1

			/*call application callback*/
			flashing_vidRxNotification(au8RxBuffer , u8len) ;
    771e:	8d e6       	ldi	r24, 0x6D	; 109
    7720:	90 e0       	ldi	r25, 0x00	; 0
    7722:	0e 94 3e 3a 	call	0x747c	; 0x747c <flashing_vidRxNotification>
		}
	}
}
    7726:	ff 91       	pop	r31
    7728:	ef 91       	pop	r30
    772a:	bf 91       	pop	r27
    772c:	af 91       	pop	r26
    772e:	9f 91       	pop	r25
    7730:	8f 91       	pop	r24
    7732:	7f 91       	pop	r23
    7734:	6f 91       	pop	r22
    7736:	5f 91       	pop	r21
    7738:	4f 91       	pop	r20
    773a:	3f 91       	pop	r19
    773c:	2f 91       	pop	r18
    773e:	0f 90       	pop	r0
    7740:	0f be       	out	0x3f, r0	; 63
    7742:	0f 90       	pop	r0
    7744:	1f 90       	pop	r1
    7746:	18 95       	reti

00007748 <__eerd_byte_m32>:
    7748:	e1 99       	sbic	0x1c, 1	; 28
    774a:	fe cf       	rjmp	.-4      	; 0x7748 <__eerd_byte_m32>
    774c:	9f bb       	out	0x1f, r25	; 31
    774e:	8e bb       	out	0x1e, r24	; 30
    7750:	e0 9a       	sbi	0x1c, 0	; 28
    7752:	99 27       	eor	r25, r25
    7754:	8d b3       	in	r24, 0x1d	; 29
    7756:	08 95       	ret

00007758 <__eeupd_byte_m32>:
    7758:	26 2f       	mov	r18, r22

0000775a <__eeupd_r18_m32>:
    775a:	e1 99       	sbic	0x1c, 1	; 28
    775c:	fe cf       	rjmp	.-4      	; 0x775a <__eeupd_r18_m32>
    775e:	9f bb       	out	0x1f, r25	; 31
    7760:	8e bb       	out	0x1e, r24	; 30
    7762:	e0 9a       	sbi	0x1c, 0	; 28
    7764:	01 97       	sbiw	r24, 0x01	; 1
    7766:	0d b2       	in	r0, 0x1d	; 29
    7768:	02 16       	cp	r0, r18
    776a:	31 f0       	breq	.+12     	; 0x7778 <__eeupd_r18_m32+0x1e>
    776c:	2d bb       	out	0x1d, r18	; 29
    776e:	0f b6       	in	r0, 0x3f	; 63
    7770:	f8 94       	cli
    7772:	e2 9a       	sbi	0x1c, 2	; 28
    7774:	e1 9a       	sbi	0x1c, 1	; 28
    7776:	0f be       	out	0x3f, r0	; 63
    7778:	08 95       	ret

0000777a <_exit>:
    777a:	f8 94       	cli

0000777c <__stop_program>:
    777c:	ff cf       	rjmp	.-2      	; 0x777c <__stop_program>
