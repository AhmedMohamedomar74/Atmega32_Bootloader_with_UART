import serial
import time

# Initialize the serial connection (replace with your settings)
ser = serial.Serial('COM2', 9600, timeout=1)

program_data = [
    0x0C, 0x94, 0x2A, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3E, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x0C, 0x94, 0x3C, 0x00, 0x11, 0x24, 0x1F, 0xBE, 0xCF, 0xE5, 0xD8, 0xE0, 0xDE, 0xBF, 0xCD, 0xBF, 0x11, 0xE0, 0xA0, 0xE6, 0xB0, 0xE0, 0x01, 0xC0, 0x1D, 0x92, 0xA3, 0x36, 0xB1, 0x07, 0xE1, 0xF7, 0x0E, 0x94, 0x7B, 0x00, 0x0C, 0x94, 0xB5, 0x00, 0x0C, 0x94, 0x00, 0x00, 0x1F, 0x92, 0x0F, 0x92, 0x0F, 0xB6, 0x0F, 0x92, 0x11, 0x24, 0x8F, 0x93, 0x9F, 0x93, 0xEF, 0x93, 0xFF, 0x93, 0x80, 0x91, 0x63, 0x00, 0x88, 0x23, 0x39, 0xF4, 0x8C, 0xB1, 0x80, 0x93, 0x61, 0x00, 0x81, 0xE0, 0x80, 0x93, 0x63, 0x00, 0x20, 0xC0, 0x90, 0x91, 0x62, 0x00, 0x8C, 0xB1, 0xE9, 0x2F, 0xF0, 0xE0, 0xEC, 0x59, 0xFF, 0x4F, 0x80, 0x83, 0x9F, 0x5F, 0x90, 0x93, 0x62, 0x00, 0x80, 0x91, 0x61, 0x00, 0x98, 0x17, 0x89, 0xF4, 0x10, 0x92, 0x62, 0x00, 0x10, 0x92, 0x63, 0x00, 0x92, 0x30, 0x59, 0xF4, 0x80, 0x91, 0x64, 0x00, 0x80, 0x31, 0x39, 0xF4, 0x80, 0x91, 0x65, 0x00, 0x83, 0x30, 0x19, 0xF4, 0x81, 0xE0, 0x80, 0x93, 0x60, 0x00, 0xFF, 0x91, 0xEF, 0x91, 0x9F, 0x91, 0x8F, 0x91, 0x0F, 0x90, 0x0F, 0xBE, 0x0F, 0x90, 0x1F, 0x90, 0x18, 0x95, 0x1F, 0x93, 0xCF, 0x93, 0xDF, 0x93, 0x8F, 0xEF, 0x8A, 0xBB, 0x81, 0xE0, 0x8B, 0xBB, 0x8D, 0xE4, 0x89, 0xB9, 0x10, 0xBC, 0x86, 0xE8, 0x80, 0xBD, 0x88, 0xE1, 0x8A, 0xB9, 0x57, 0x9A, 0x78, 0x94, 0x13, 0xE0, 0xCC, 0xE2, 0xD1, 0xE0, 0x8B, 0xB3, 0x81, 0x27, 0x8B, 0xBB, 0x80, 0xE1, 0x97, 0xE2, 0xFE, 0x01, 0x31, 0x97, 0xF1, 0xF7, 0x01, 0x97, 0xD9, 0xF7, 0x80, 0x91, 0x60, 0x00, 0x81, 0x30, 0x91, 0xF7, 0x81, 0xE0, 0x90, 0xE0, 0x61, 0xE0, 0x0E, 0x94, 0xA4, 0x00, 0x0C, 0x94, 0x00, 0x38, 0xEA, 0xCF, 0x26, 0x2F, 0xE1, 0x99, 0xFE, 0xCF, 0x9F, 0xBB, 0x8E, 0xBB, 0xE0, 0x9A, 0x01, 0x97, 0x0D, 0xB2, 0x02, 0x16, 0x31, 0xF0, 0x2D, 0xBB, 0x0F, 0xB6, 0xF8, 0x94, 0xE2, 0x9A, 0xE1, 0x9A, 0x0F, 0xBE, 0x08, 0x95, 0xF8, 0x94, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
]

# Calculate the size of the array
program_size = len(program_data)
print(f"Size of program = {program_size}")

# Convert program_size to little-endian byte array
program_size_bytes = program_size.to_bytes((program_size.bit_length() + 7) // 8, 'big')

print(f"Length of program = {program_size_bytes}")

def calculate_crc(data):
    crc = 0xFFFF  # Initialize CRC to 0xFFFF
    polynomial = 0xA001  # Polynomial used in C code

    for byte in data:
        crc ^= byte  # XOR byte into CRC
        for _ in range(8):
            if crc & 1:  # Check if the lowest bit is set
                crc = (crc >> 1) ^ polynomial  # Shift right and XOR with polynomial
            else:
                crc >>= 1  # Just shift right
        crc &= 0xFFFF  # Ensure CRC remains 16-bit

    # Return CRC as a single 2-byte variable in little-endian order
    low_byte = crc & 0xFF  # Low byte
    high_byte = (crc >> 8) & 0xFF  # High byte
    return low_byte, high_byte  # Return bytes separately

CRC_high, CRC_low = calculate_crc(program_data)
print(f"CRC High Byte: {CRC_high}, CRC Low Byte: {CRC_low}")

# States with CRC bytes properly handled
states = [
    bytes([0x10, 0x03]),  # SESSION_CONTROL
    bytes([0x34, 0x00] + list(program_size_bytes)),  # DOWNLOAD_REQUEST with size in little-endian
    bytes([0x37]),  # TRANSFER_EXIT
    bytes([0x31, CRC_high, CRC_low])   # CHECK_CRC with CRC bytes
]

def send_state_with_response(state):
    # Send the length of the state (1 byte)
    state_length = len(state)
    ser.write(bytes([state_length]))

    # Send the actual state
    ser.write(state)
    time.sleep(1)  # Wait 1 second between states, as per your requirement

    # Read the response (1 byte)
    response = ser.read(1)
    if response:
        expected_response = state[0] + 0x40
        if response[0] == expected_response:
            print(f"Received valid response: {response.hex()}")
            return True
        else:
            print(f"Invalid response: {response.hex()}, expected: {hex(expected_response)}")
            return False
    else:
        print("No response received.")
        return False

def send_transfer_data():
    chunk_size = 128  # Size of each chunk
    total_size = len(program_data)
    index = 0

    while index < total_size:
        chunk = program_data[index:index + chunk_size]

        # If chunk is less than 128 bytes, pad with 0xFF
        if len(chunk) < chunk_size:
            chunk += [0xFF] * (chunk_size - len(chunk))

        # Create the transfer data packet (0x36 + 128 bytes)
        transfer_state = bytes([0x36]) + bytes(chunk)
        
        print(f"Sending chunk from index {index} to {index + chunk_size}")
        
        # Send the transfer state and check response
        if not send_state_with_response(transfer_state):
            print(f"Error in transferring chunk starting at index {index}. Retrying.")
            continue  # Retry sending the same chunk if an error occurs

        # Move to the next chunk
        index += chunk_size

def send_all_states():
    # Send initial states (SESSION_CONTROL and DOWNLOAD_REQUEST)
    for state in states[:-2]:
        if not send_state_with_response(state):
            print("Error occurred. Stopping.")
            return

    # Handle the TRANSFER_DATA state by sending chunks
    send_transfer_data()

    # Send remaining states (TRANSFER_EXIT, CHECK_CRC)
    for state in states[-2:]:
        if not send_state_with_response(state):
            print("Error occurred. Stopping.")
            break

# Send all the states
send_all_states()

# Close the serial connection
ser.close()